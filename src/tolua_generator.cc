#include <string>
#include <vector>
#include <map>

#include "tolua_generator.h"

#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>

#include "utils.h"

using namespace google::protobuf;

namespace protolua {

namespace {

inline std::string PkgName(const std::string& filename) {
    return utils::string::StripSuffix(filename, ".proto") + ".pkg";
}

class FileGenerator {
public:
    explicit FileGenerator(const FileDescriptor* file);
    ~FileGenerator();

    void PrintTopBoilerplate(io::Printer* printer);
    void PrintIncludes(io::Printer* printer);
    void PrintNamespaceOpeners(io::Printer* printer);
    void PrintNamespaceClosers(io::Printer* printer);
    void PrintEnumration(const EnumDescriptor* descriptor, io::Printer* printer);
    void PrintNestedEnumration(const Descriptor* descriptor, io::Printer* printer);
    void PrintMessage(const Descriptor* descriptor, io::Printer* printer);
    void PrintCommonFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintPrimitiveFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintEnumFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintStringFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintMessageFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintRepeatedPrimitiveFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintRepeatedEnumFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintRepeatedStringFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintRepeatedMessageFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);
    void PrintFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer);

private:
    const FileDescriptor* file_;
    // E.g. if the package is foo.bar, package_parts_ is {"foo", "bar"}.
    std::vector<string> package_parts_;
};

FileGenerator::FileGenerator(const FileDescriptor* file)
    : file_(file) {
    utils::string::Split(file->package(), ".", &package_parts_);
}

FileGenerator::~FileGenerator() {
}

void FileGenerator::PrintTopBoilerplate(io::Printer* printer) {
    printer->Print(
        "// Generated by protolua.  DO NOT EDIT!\n"
        "// source: @filename@\n",
        "filename", file_->name());
}

void FileGenerator::PrintIncludes(io::Printer* printer) {
    printer->Print(
        "$#include \"@pb_header@\"\n",
        "pb_header", utils::protoc::ProtoHeaderName(file_->name()));
}

void FileGenerator::PrintNamespaceOpeners(io::Printer* printer) {
  if (package_parts_.size() > 0) printer->Print("\n");

  for (size_t i = 0; i < package_parts_.size(); i++) {
    printer->Print("namespace @part@ {\n",
                   "part", package_parts_[i]);
  }
}

void FileGenerator::PrintNamespaceClosers(io::Printer* printer) {
  if (package_parts_.size() > 0) printer->Print("\n");

  for (int i = package_parts_.size() - 1; i >= 0; i--) {
    printer->Print("}  // namespace @part@\n",
                   "part", package_parts_[i]);
  }
}

void FileGenerator::PrintEnumration(const EnumDescriptor* descriptor,
                                       io::Printer* printer) {

    std::string name_prefix =
        (descriptor->containing_type() == NULL) ?
        "" :
        utils::protoc::ClassName(descriptor, false);

    printer->Print(
        "enum @name@ {\n",
        "name", descriptor->name());
    printer->Indent();

    const EnumValueDescriptor* min_value = descriptor->value(0);
    const EnumValueDescriptor* max_value = descriptor->value(0);

    for (int i = 0; i < descriptor->value_count(); i++) {
        if (i > 0) {
            printer->Print(",\n");
        }

        printer->Print(
            "@prefix@@name@ = @number@",
            "prefix", name_prefix,
            "name", descriptor->value(i)->name(),
            "number", utils::protoc::EnumIToA(descriptor->value(i)->number()));

        if (descriptor->value(i)->number() < min_value->number()) {
            min_value = descriptor->value(i);
        }
        if (descriptor->value(i)->number() > max_value->number()) {
            max_value = descriptor->value(i);
        }
    }

    printer->Outdent();
    printer->Print("\n};\n\n");
}

void FileGenerator::PrintNestedEnumration(const Descriptor* descriptor, io::Printer* printer) {
    for (int i = 0; i < descriptor->enum_type_count(); ++i) {
        PrintEnumration(descriptor->enum_type(i), printer);
    }

    for (int i = 0; i < descriptor->nested_type_count(); ++i) {
        PrintNestedEnumration(descriptor->nested_type(i), printer);
    }
}

void FileGenerator::PrintMessage(const Descriptor* descriptor, io::Printer* printer) {
    for (int i = 0; i < descriptor->nested_type_count(); i++) {
        PrintMessage(descriptor->nested_type(i), printer);
        printer->Print("\n");
    }

    std::map<std::string, std::string> vars;

    vars["classname"] = utils::protoc::ClassName(descriptor, false);
    vars["superclass"] = utils::protoc::SuperClassName(descriptor);

    printer->Print(vars,
        "class @classname@ : public @superclass@ {\n"
        " public:\n");
    printer->Indent();

    printer->Print(vars,
        "@classname@();\n"
        "virtual ~@classname@();\n"
        "\n"
        "@classname@(const @classname@& from);\n"
        "\n");

    for (int i = 0; i < descriptor->oneof_decl_count(); i++) {
        printer->Print(
            "enum @camel_oneof_name@Case {\n",
            "camel_oneof_name",
            utils::string::UnderscoresToCamelCase(descriptor->oneof_decl(i)->name(), true));

        printer->Indent();
        for (int j = 0; j < descriptor->oneof_decl(i)->field_count(); j++) {
            printer->Print(
                "k@field_name@ = @field_number@,\n",
                "field_name",
                utils::string::UnderscoresToCamelCase(
                    descriptor->oneof_decl(i)->field(j)->name(), true),
                "field_number",
                utils::string::SimpleItoa(descriptor->oneof_decl(i)->field(j)->number()));
        }
        printer->Print(
            "@cap_oneof_name@_NOT_SET = 0,\n",
            "cap_oneof_name",
            utils::string::ToUpper(descriptor->oneof_decl(i)->name()));
        printer->Outdent();
        printer->Print(
            "};\n"
            "\n");
    }

    printer->Print(vars, "void Swap(@classname@* other);\n");

    if (utils::protoc::HasGeneratedMethods(descriptor->file())) {
        if (utils::protoc::HasDescriptorMethods(descriptor->file())) {
            printer->Print(vars,
                "void CopyFrom(const ::google::protobuf::Message& from);\n"
                "void MergeFrom(const ::google::protobuf::Message& from);\n"
                "std::string DebugString() const;\n"
                "std::string ShortDebugString() const;\n"
                "std::string Utf8DebugString() const;\n");
        } else {
            printer->Print(vars,
                "void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);\n");
        }

        printer->Print(vars,
            "bool ParseFromArray(const char* data, int size);\n"
            "bool ParsePartialFromArray(const char* data, int size);\n"
            "bool SerializeToString(std::string* output) const;\n"
            "bool SerializePartialToString(std::string* output) const;\n"
            "std::string SerializeAsString() const;\n"
            "std::string SerializePartialAsString() const;\n"
            "void CopyFrom(const @classname@& from);\n"
            "void MergeFrom(const @classname@& from);\n"
            "void Clear();\n"
            "bool IsInitialized() const;\n"
            "\n");
    }

    for (int i = 0; i < descriptor->field_count(); i++) {
        PrintFieldAccessors(descriptor->field(i), printer);
        printer->Print("\n");
    }

    for (int i = 0; i < descriptor->oneof_decl_count(); i++) {
        printer->Print(
            "inline @camel_oneof_name@Case @oneof_name@_case() const;\n",
            "camel_oneof_name",
            utils::string::UnderscoresToCamelCase(descriptor->oneof_decl(i)->name(), true),
            "oneof_name", descriptor->oneof_decl(i)->name());
    }

    printer->Outdent();
    printer->Print(vars, "};\n\n");
}

void FileGenerator::PrintCommonFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    if (descriptor->is_repeated()) {
        printer->Print(
            "inline int @name@_size() const;\n"
            "inline void clear_@name@();\n",
            "name", utils::protoc::FieldName(descriptor));
    } else {
        printer->Print(
            "inline bool has_@name@() const;\n"
            "inline void clear_@name@();\n",
            "name", utils::protoc::FieldName(descriptor));
    }
}

void FileGenerator::PrintPrimitiveFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    printer->Print(
        "inline @type@ @name@() const;\n"
        "inline void set_@name@(@type@ value);\n",
        "name", utils::protoc::FieldName(descriptor),
        "type", protolua::utils::protoc::PrimitiveTypeName(descriptor->cpp_type()));
}

void FileGenerator::PrintEnumFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    printer->Print(
        "inline @type@ @name@() const;\n"
        "inline void set_@name@(@type@ value);\n",
        "name", utils::protoc::FieldName(descriptor),
        "type", protolua::utils::protoc::ClassName(descriptor->enum_type(), true));
}

void FileGenerator::PrintStringFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    if (descriptor->options().ctype() != FieldOptions::STRING) {
        // Skip unknown ctype option.
        return;
    }

    printer->Print(
        "inline const std::string& @name@() const;\n"
        "inline void set_@name@(const std::string& value);\n"
        "inline void set_@name@(const char* value);\n"
        "inline void set_@name@(const @pointer_type@* value, uint64_t size);\n"
        "inline void set_allocated_@name@(std::string* @name@);\n",
        "name", utils::protoc::FieldName(descriptor),
        "pointer_type", (descriptor->type() == FieldDescriptor::TYPE_BYTES ? "void" : "char"),
        "release_name", utils::protoc::SafeFunctionName(descriptor->containing_type(), descriptor, "release_"));
}

void FileGenerator::PrintMessageFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    printer->Print(
        "inline const @type@& @name@() const;\n"
        "inline @type@* mutable_@name@();\n"
        "inline @type@* @release_name@();\n"
        "inline void set_allocated_@name@(@type@* @name@);\n",
        "name", utils::protoc::FieldName(descriptor),
        "type", protolua::utils::protoc::ClassName(descriptor->message_type(), true),
        "release_name", utils::protoc::SafeFunctionName(descriptor->containing_type(), descriptor, "release_"));
}

void FileGenerator::PrintRepeatedPrimitiveFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    printer->Print(
        "inline @type@ @name@(int index) const;\n"
        "inline void set_@name@(int index, @type@ value);\n"
        "inline void add_@name@(@type@ value);\n",
        "name", utils::protoc::FieldName(descriptor),
        "type", protolua::utils::protoc::PrimitiveTypeName(descriptor->cpp_type()));
}

void FileGenerator::PrintRepeatedEnumFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    printer->Print(
        "inline @type@ @name@(int index) const;\n"
        "inline void set_@name@(int index, @type@ value);\n"
        "inline void add_@name@(@type@ value);\n",
        "name", utils::protoc::FieldName(descriptor),
        "type", protolua::utils::protoc::ClassName(descriptor->enum_type(), true));
}

void FileGenerator::PrintRepeatedStringFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
    if (descriptor->options().ctype() != FieldOptions::STRING) {
        // Skip unknown ctype option.
        return;
    }

    printer->Print(
        "inline const std::string& @name@(int index) const;\n"
        "inline void set_@name@(int index, const std::string& value);\n"
        "inline void set_@name@(int index, const char* value);\n"
        "inline void set_@name@(int index, const @pointer_type@* value, uint64_t size);\n"
        "inline void add_@name@(const std::string& value);\n"
        "inline void add_@name@(const char* value);\n"
        "inline void add_@name@(const @pointer_type@* value, uint64_t size);\n",
        "name", utils::protoc::FieldName(descriptor),
        "pointer_type", (descriptor->type() == FieldDescriptor::TYPE_BYTES ? "void" : "char"));
}

void FileGenerator::PrintRepeatedMessageFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {
      printer->Print(
        "inline const @type@& @name@(int index) const;\n"
        "inline @type@* mutable_@name@(int index);\n"
        "inline @type@* add_@name@();\n",
        "name", utils::protoc::FieldName(descriptor),
        "type", protolua::utils::protoc::ClassName(descriptor->message_type(), true));
}

void FileGenerator::PrintFieldAccessors(const FieldDescriptor* descriptor, io::Printer* printer) {

    PrintCommonFieldAccessors(descriptor, printer);

    if (descriptor->is_repeated()) {
        switch (descriptor->cpp_type()) {
        case FieldDescriptor::CPPTYPE_MESSAGE:
            PrintRepeatedMessageFieldAccessors(descriptor, printer);
            break;
        case FieldDescriptor::CPPTYPE_STRING:
            // RepeatedStringFieldAccessors handles unknown ctypes.
            PrintRepeatedStringFieldAccessors(descriptor, printer);
            break;
        case FieldDescriptor::CPPTYPE_ENUM:
            PrintRepeatedEnumFieldAccessors(descriptor, printer);
            break;
        default:
            PrintRepeatedPrimitiveFieldAccessors(descriptor, printer);
            break;
        }
    } else {
        switch (descriptor->cpp_type()) {
        case FieldDescriptor::CPPTYPE_MESSAGE:
            PrintMessageFieldAccessors(descriptor, printer);
            break;
        case FieldDescriptor::CPPTYPE_STRING:
            // StringField branch handles unknown ctypes.
            PrintStringFieldAccessors(descriptor, printer);
            break;
        case FieldDescriptor::CPPTYPE_ENUM:
            PrintEnumFieldAccessors(descriptor, printer);
            break;
        default:
            PrintPrimitiveFieldAccessors(descriptor, printer);
            break;
        }
    }
}

} // namespace

ToluaGenerator::ToluaGenerator() {
}

ToluaGenerator::~ToluaGenerator() {
}

bool ToluaGenerator::Generate(const FileDescriptor* file,
                              const std::string& parameter,
                              compiler::GeneratorContext* generator_context,
                              std::string* error) const {

    FileGenerator file_generator(file);
    const std::string output_filename = PkgName(file->name());

    internal::scoped_ptr<io::ZeroCopyOutputStream> output(generator_context->Open(output_filename));
    GOOGLE_CHECK(output.get());
    io::Printer printer(output.get(), '@');

    file_generator.PrintTopBoilerplate(&printer);
    printer.Print("\n");

    file_generator.PrintIncludes(&printer);
    printer.Print("\n");

    file_generator.PrintNamespaceOpeners(&printer);
    printer.Print("\n");

    for (int i = 0; i < file->enum_type_count(); i++) {
        file_generator.PrintEnumration(file->enum_type(i), &printer);
    }
    for (int i = 0; i < file->message_type_count(); i++) {
        file_generator.PrintNestedEnumration(file->message_type(i), &printer);
    }
    printer.Print("\n");

    for (int i = 0; i < file->message_type_count(); i++) {
        file_generator.PrintMessage(file->message_type(i), &printer);
    }
    printer.Print("\n");
    
    file_generator.PrintNamespaceClosers(&printer);
    printer.Print("\n");

    return true;
}

} // namespace protolua
